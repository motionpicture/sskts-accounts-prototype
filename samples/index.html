<html>

<head>
</head>

<body>
    <a href="javascript:void(0);" onclick="tryAuthorize();">ログイン</a><br>
    <a href="javascript:void(0);" onclick="tryRenewAuth();">再認可</a>
    <p>
        idToken:<br>
        <textarea id="idToken" readonly rows="30" cols="80"></textarea>
    </p>
    <p>
        accessToken:<br>
        <textarea id="accessToken" readonly rows="30" cols="80"></textarea>
    </p>
</body>
<script>
    const CLIENT_ID = '6figun12gcdtlj9e53p2u3oqvl'; // 会員トークンプロバイダーに発行してもらうこと
    const CALLBACK_URL = 'http://localhost:8080/authorizeCallback.html'; // アプリケーション側で適宜ページを用意する

    function tryAuthorize() {
        var options = {
            clientId: CLIENT_ID,
            responseType: 'id_token token',
            responseMode: 'fragment',
            prompt: '',
            redirectUri: CALLBACK_URL,
            scope: 'openid',
            state: '12345',
            nonce: ''
        };

        authorize(options, function (err, result) {
            if (err) {
                return console.log(err);
            }

            console.log('authorize result:', result);
            document.getElementById('idToken').innerText = result.idToken;
            document.getElementById('accessToken').innerText = result.accessToken;
        });
    }

    function tryRenewAuth() {
        var options = {
            clientId: CLIENT_ID,
            responseType: 'id_token token',
            responseMode: 'fragment',
            prompt: 'none',
            redirectUri: CALLBACK_URL,
            scope: 'openid',
            state: '12345',
            nonce: ''
        };

        renewAuth(options, function (err, result) {
            if (err) {
                return console.log(err);
            }

            console.log('tryRenewAuth result:', result);
            document.getElementById('idToken').innerText = result.idToken;
            document.getElementById('accessToken').innerText = result.accessToken;
        });
    }

    function authorize(options, cb) {
        var handler;
        var usePostMessage = !!options.usePostMessage;

        var params = {
            clientId: options.clientId || '',
            responseType: options.responseType || 'id_token token',
            responseMode: options.responseMode || 'fragment',
            prompt: options.prompt || '',
            redirectUri: options.redirectUri,
            scope: options.scope || 'openid',
            state: options.state || '',
            nonce: options.nonce || ''
        };

        handler = PopupAuthenticationHandler.create({
            authenticationUrl: buildAuthorizeUrl(params)
        });

        // 認可画面を新規タブで開く
        handler.login(function (err, hash) {
            if (typeof hash === 'object') {
                // hash was already parsed, so we just return it.
                return cb(err, hash);
            }

            console.log('popup logined', err, hash);
            parseHash({
                hash: hash,
                // nonce: transactionNonce,
                // state: transactionState
            }, cb);
        });
    };

    function buildAuthorizeUrl(options) {
        return 'http://localhost:3333/authorize' +
            '?client_id=' + options.clientId +
            '&response_type=' + options.responseType +
            '&redirect_uri=' + encodeURIComponent(options.redirectUri) +
            '&response_mode=' + options.responseMode +
            '&scope=' + options.scope +
            '&state=' + options.state +
            '&nonce=' + options.nonce +
            '&prompt=' + options.prompt;
    };

    function renewAuth(options, cb) {
        var handler;
        var usePostMessage = !!options.usePostMessage;

        var params = {
            clientId: options.clientId || '',
            responseType: options.responseType || 'id_token token',
            responseMode: options.responseMode || 'fragment',
            prompt: 'none',
            redirectUri: options.redirectUri,
            scope: options.scope || 'openid',
            state: options.state || '',
            nonce: options.nonce || '',
        };

        var _this = this;

        handler = SilentAuthenticationHandler.create({
            authenticationUrl: buildAuthorizeUrl(params)
        });

        handler.login(usePostMessage, function (err, hash) {
            console.log('iframe logined', err, hash);
            if (typeof hash === 'object') {
                // hash was already parsed, so we just return it.
                // it's here to be backwards compatible and should be removed in the next major version.
                return cb(err, hash);
            }

            // var transaction = _this.transactionManager.getStoredTransaction(params.state);
            // var transactionNonce = options.nonce || (transaction && transaction.nonce) || null;
            // var transactionState = options.state || (transaction && transaction.state) || null;
            parseHash({
                hash: hash,
                // nonce: transactionNonce,
                // state: transactionState
            }, cb);
        });
    };

    function parseHash(options, cb) {
        var parsedQs = {};
        var hashStr = (options.hash === undefined) ? window.location.hash : options.hash;
        hashStr = hashStr.replace(/^#?\/?/, '');
        console.log('hashStr:', hashStr);
        hashStr.split('&').forEach(function (keyValue) {
            parsedQs[keyValue.split('=')[0]] = keyValue.split('=')[1];
        });
        // parsedQs = qs.parse(hashStr);

        if (parsedQs.hasOwnProperty('error')) {
            var err = {
                error: parsedQs.error,
                errorDescription: parsedQs.error_description
            };

            if (parsedQs.state) {
                err.state = parsedQs.state;
            }

            return cb(err);
        }

        if (
            !parsedQs.hasOwnProperty('access_token') &&
            !parsedQs.hasOwnProperty('id_token') &&
            !parsedQs.hasOwnProperty('refresh_token')
        ) {
            return cb(null, null);
        }

        cb(null, buildParseHashResponse(parsedQs));
    };

    function buildParseHashResponse(qsParams) {
        return {
            accessToken: qsParams.access_token || null,
            idToken: qsParams.id_token || null,
            state: qsParams.state || null,
            expiresIn: qsParams.expires_in ? parseInt(qsParams.expires_in, 10) : null,
            tokenType: qsParams.token_type || null,
            scope: qsParams.scope || null
        };
    }


    function PopupAuthenticationHandler(options) {
        this.authenticationUrl = options.authenticationUrl;
        this.timeout = options.timeout || 60 * 1000;
        this.handler = null;
    }

    PopupAuthenticationHandler.create = function (options) {
        return new PopupAuthenticationHandler(options);
    };

    PopupAuthenticationHandler.prototype.login = function (callback) {
        this.handler = new PopupHandler({
            auth0: this.auth0,
            url: this.authenticationUrl,
            eventListenerType: 'message',
            callback: this.getCallbackHandler(callback),
            timeout: this.timeout,
            eventValidator: this.getEventValidator(),
            timeoutCallback: function () {
                callback(null, '#error=timeout&error_description=Timeout+during+authentication+renew.');
            },
            usePostMessage: false
        });

        this.handler.init();
    };

    PopupAuthenticationHandler.prototype.getEventValidator = function () {
        return {
        };
    };

    PopupAuthenticationHandler.prototype.getCallbackHandler = function (callback) {
        return function (eventData) {
            var callbackValue;
            if (typeof eventData.event.data === 'object' && eventData.event.data.hash) {
                callbackValue = eventData.event.data.hash;
            } else {
                callbackValue = eventData.event.data;
            }
            callback(null, callbackValue);
        };
    };




    function SilentAuthenticationHandler(options) {
        this.authenticationUrl = options.authenticationUrl;
        this.timeout = options.timeout || 60 * 1000;
        this.handler = null;
    }

    SilentAuthenticationHandler.create = function (options) {
        return new SilentAuthenticationHandler(options);
    };

    SilentAuthenticationHandler.prototype.login = function (usePostMessage, callback) {
        this.handler = new IframeHandler({
            auth0: this.auth0,
            url: this.authenticationUrl,
            eventListenerType: usePostMessage ? 'message' : 'load',
            callback: this.getCallbackHandler(callback, usePostMessage),
            timeout: this.timeout,
            eventValidator: this.getEventValidator(),
            timeoutCallback: function () {
                callback(null, '#error=timeout&error_description=Timeout+during+authentication+renew.');
            },
            usePostMessage: usePostMessage || false
        });

        this.handler.init();
    };

    SilentAuthenticationHandler.prototype.getEventValidator = function () {
        return {
        };
    };

    SilentAuthenticationHandler.prototype.getCallbackHandler = function (callback, usePostMessage) {
        return function (eventData) {
            var callbackValue;
            if (!usePostMessage) {
                callbackValue = eventData.sourceObject.contentWindow.location.hash;
            } else if (typeof eventData.event.data === 'object' && eventData.event.data.hash) {
                callbackValue = eventData.event.data.hash;
            } else {
                callbackValue = eventData.event.data;
            }
            callback(null, callbackValue);
        };
    };

    function IframeHandler(options) {
        this.url = options.url;
        this.callback = options.callback;
        this.timeout = options.timeout || 60 * 1000;
        this.timeoutCallback = options.timeoutCallback || null;
        this.eventListenerType = options.eventListenerType || 'message';
        this.iframe = null;
        this.timeoutHandle = null;
        this._destroyTimeout = null;
        this.proxyEventListener = null;
        // If no event identifier specified, set default
        this.eventValidator = options.eventValidator || {
            isValid: function () {
                return true;
            }
        };

        if (typeof this.callback !== 'function') {
            throw new Error('options.callback must be a function');
        }
    }

    IframeHandler.prototype.init = function () {
        console.log('opening iframe...', this.eventListenerType);
        var _this = this;
        var _window = window;

        this.iframe = _window.document.createElement('iframe');
        this.iframe.style.display = 'none';
        this.iframe.src = this.url;

        // Workaround to avoid using bind that does not work in IE8
        this.proxyEventListener = function (e) {
            _this.eventListener(e);
        };

        switch (this.eventListenerType) {
            case 'message':
                this.eventSourceObject = _window;
                break;
            case 'load':
                this.eventSourceObject = this.iframe;
                break;
            default:
                throw new Error('Unsupported event listener type: ' + this.eventListenerType);
        }

        this.eventSourceObject.addEventListener(this.eventListenerType, this.proxyEventListener, false);

        _window.document.body.appendChild(this.iframe);

        this.timeoutHandle = setTimeout(function () {
            _this.timeoutHandler();
        }, this.timeout);
    };

    IframeHandler.prototype.eventListener = function (event) {
        var eventData = { event: event, sourceObject: this.eventSourceObject };

        this.destroy();
        this.callback(eventData);
    };

    IframeHandler.prototype.timeoutHandler = function () {
        this.destroy();
        if (this.timeoutCallback) {
            this.timeoutCallback();
        }
    };

    IframeHandler.prototype.destroy = function () {
        var _this = this;
        var _window = window;

        clearTimeout(this.timeoutHandle);

        this._destroyTimeout = setTimeout(function () {
            _this.eventSourceObject.removeEventListener(
                _this.eventListenerType,
                _this.proxyEventListener,
                false
            );
            _window.document.body.removeChild(_this.iframe);
        }, 0);
    };

    function PopupHandler(options) {
        this.url = options.url;
        this.callback = options.callback;
        this.timeout = options.timeout || 60 * 1000;
        this.timeoutCallback = options.timeoutCallback || null;
        this.eventListenerType = options.eventListenerType || 'message';
        this.popupWindow = null;
        this.timeoutHandle = null;
        this._destroyTimeout = null;
        this.proxyEventListener = null;
        // If no event identifier specified, set default
        this.eventValidator = options.eventValidator || {
            isValid: function () {
                return true;
            }
        };

        if (typeof this.callback !== 'function') {
            throw new Error('options.callback must be a function');
        }
    }

    PopupHandler.prototype.init = function () {
        console.log('opening popup...', this.eventListenerType);
        var _this = this;
        var _window = window;

        this.popupWindow = _window.open(this.url, 'authorizeWindow');

        // Workaround to avoid using bind that does not work in IE8
        this.proxyEventListener = function (e) {
            _this.eventListener(e);
        };

        switch (this.eventListenerType) {
            case 'message':
                this.eventSourceObject = _window;
                break;
            case 'load':
                this.eventSourceObject = this.popupWindow;
                break;
            default:
                throw new Error('Unsupported event listener type: ' + this.eventListenerType);
        }

        console.log('this.eventSourceObject:', this.eventSourceObject);
        this.eventSourceObject.addEventListener(this.eventListenerType, this.proxyEventListener, false);

        this.timeoutHandle = setTimeout(function () {
            _this.timeoutHandler();
        }, this.timeout);
    };

    PopupHandler.prototype.eventListener = function (event) {
        var eventData = { event: event, sourceObject: this.eventSourceObject };
        console.log('PopupHandler.eventListener...', eventData);

        // 呼び出し元へコールバック
        this.callback(eventData);
        // ポップアップを閉じる
        this.popupWindow.close();
    };

    PopupHandler.prototype.timeoutHandler = function () {
        if (this.timeoutCallback) {
            this.timeoutCallback();
        }
    };

</script>

</html>